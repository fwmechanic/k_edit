--
--  tu.lua  Copyright 2006 by Kevin L. Goodwin; All rights reserved
--

module( "tu", package.seeall )  --  Table Utils library

do
   local function a_flatten_( rv, ary )
      for _ ,val in ipairs(ary) do
         if type(val) == "table" then a_flatten_( rv, val )
         else rv[ #rv + 1 ] = val end
         end
      return rv
      end

   -- usage a_flatten{ a1, a2, { a3, a4 } }
   function a_flatten( ary )  return a_flatten_( {}, ary )  end
end

function a_print( ary, indent )
   indent = indent or ""
   for _ ,val in ipairs(ary) do
      if type(val) == "table" then print( indent..'{' )  a_print( val, indent .. "   " )  print( indent..'}' )
      else print( indent..val ) end
      end
   end

-- a_print{ 1, 2, { 3, 4 } }
-- a_print( a_flatten{ 1, 2, { 3, 4 } } )

function a_cat( ... ) local rv = {} for _,tbl in ipairs{ ...  } do for _,val in ipairs(tbl) do rv[ #rv + 1 ] = val end end return rv end
function a_reduce(fx,ary,acc)              for _ ,val in ipairs(ary) do acc = fx( acc, val ) end return acc end
function a_grep(  fx,ary )   local rv = {} for ky,val in ipairs(ary) do if fx( val ) then rv[ #rv + 1 ] = val end end return rv end
function a_grepv( fx,ary )   local rv = {} for ky,val in ipairs(ary) do local nval = fx( val ) if nval then rv[ #rv + 1 ] = nval end end return rv end
function a_map(   fx,ary )   local rv = {} for ky,val in ipairs(ary) do rv[ ky ] = fx(val)   end return rv end
function a_reverse(  ary )   local rv = {} for ix = #ary, 1, -1      do rv[ #rv + 1 ] = ary[ ix ] end return rv end

function t_keys_array  ( tbl ) local rv = {} for ky,_  in pairs(tbl) do rv[ #rv + 1 ] = ky   end return rv end
function t_values_table( tbl ) local rv = {} for _,val in pairs(tbl) do rv[ val     ] = true end return rv end
function t_values_array( tbl ) local rv = {} for _,val in pairs(tbl) do rv[ #rv + 1 ] = val  end return rv end

function descending( a, b ) return a > b end  -- reverse sort function

--
-- pairsBySortedKeyFxn:
--    iterate thru a table ('tbl') of (sub)tables, in the sorted order of a key
--    generated by a function 'keyfxn' which is passed each key and value.
--
-- why this is so complex: it handles duplicate keys
--

function pairsBySortedKeyFxn( tbl1, keyfxn, sortfxn )
   -- print( "start: ", keyfieldnm )
   local a_idx,keyval_2_matching_key1 = {}, {}
   for key1,val1 in pairs(tbl1) do
      -- print( "kv1: ", key1,val1 )  for key2,val2 in pairs(val1) do  print( "kv2:    ", key2,val2 ) end
      local keyval = keyfxn( key1, val1 )
      t_append( keyval_2_matching_key1, keyval, key1 )
      a_idx[ #a_idx + 1 ] = keyval
      end
   table.sort( a_idx, sortfxn )

   -- flattening is easier now than in the generator closure:
   local idx,iv = 0,{}
   for _,keyval in ipairs(a_idx) do
      for _,key1 in ipairs(keyval_2_matching_key1[keyval]) do  iv[ #iv + 1 ] = key1  end
      end

   return function()
      idx = idx + 1
      local key1 = iv[ idx ]
      -- if key1 then print( "+++  ", key1 ) end
      return key1, key1 and tbl1[ key1 ] or nil
      end
   end

function pairsBySortedValues( tbl1, sortfxn )
   return pairsBySortedKeyFxn( tbl1, function(k,v) return v end, sortfxn )
   end

function field_bytes(k,v) return v.bytes end

function PairsBySortedKeys( tbl1, sortfxn )  -- from PIL 2e pg. 172-3: iterator that traverses a table following the order of its keys
   local iv = {}
   for key1,val1 in pairs(tbl1) do iv[ #iv + 1 ] = key1 end
   table.sort( iv )
   local idx = 0
   return function()
      idx = idx + 1
      local key1 = iv[ idx ]
      -- if key1 then print( "+++  ", key1 ) end
      return key1, tbl1[ key1 ]
      end
   end


function t_append( t1, k1, val )  --  t1[ k1 ] is an array, to which val will be appended
   local  a2 = t1[ k1 ]
   if a2 then  a2[ #a2+1 ] =   val         -- append to array
   else        t1[ k1 ]    = { val }  end  -- create array
   end

function t_accum( t1, k1, val )
   t1[ k1 ] = (t1[ k1 ] or 0) + val
   end
